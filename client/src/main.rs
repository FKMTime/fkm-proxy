use anyhow::Result;
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
};

const SERVER_ADDR: &str = "127.0.0.1:6969";
const LOCAL_ADDR: &str = "127.0.0.1:5000";
const URL_HASH: u64 = 11080042599982751842; // generated by server (hash of the URL)
const TOKEN: u128 = 0x6942069420; // generated by server (random token)

#[tokio::main]
async fn main() -> Result<()> {
    let mut connector = TcpStream::connect(SERVER_ADDR).await?;
    let mut conn_buff = [0u8; 64];

    conn_buff[0] = 0x00;
    conn_buff[1..9].copy_from_slice(&URL_HASH.to_be_bytes());
    conn_buff[10..26].copy_from_slice(&TOKEN.to_be_bytes());
    connector.write_all(&conn_buff).await?;

    conn_buff[0] = 0x01; // set the first byte to 0x01 to indicate that next connection is a tunnel
    loop {
        let res = connector.read_u8().await?;
        if res == 0x40 {
            tokio::task::spawn(spawn_tunnel(conn_buff));
        }
    }

    //Ok(())
}

async fn spawn_tunnel(conn_buff: [u8; 64]) -> Result<()> {
    let mut local_stream = TcpStream::connect(LOCAL_ADDR).await?;
    let mut tunnel_stream = TcpStream::connect(SERVER_ADDR).await?;
    local_stream.set_nodelay(true)?;

    tunnel_stream.write_all(&conn_buff).await?;
    tunnel_stream.set_nodelay(true)?;

    tokio::io::copy_bidirectional(&mut local_stream, &mut tunnel_stream).await?;
    Ok(())
}
