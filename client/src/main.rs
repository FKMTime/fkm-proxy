use anyhow::Result;
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
};

const SERVER_ADDR: &str = "localhost:6969";
const URL_HASH: u64 = 7464474119642741206; // generated by server (hash of the URL)
const TOKEN: u128 = 0x6942069420; // generated by server (random token)

#[tokio::main]
async fn main() -> Result<()> {
    let mut connector = TcpStream::connect(SERVER_ADDR).await?;
    let mut conn_buff = [0u8; 64];
    conn_buff[0] = 0x00;

    let url_hash_bytes = URL_HASH.to_be_bytes();
    conn_buff[1..9].copy_from_slice(&url_hash_bytes);

    let token_bytes = TOKEN.to_be_bytes();
    conn_buff[10..26].copy_from_slice(&token_bytes);

    connector.write_all(&conn_buff).await?;

    conn_buff[0] = 0x01; // set the first byte to 0x01 to indicate that next connection is a tunnel
    loop {
        let res = connector.read_u8().await?;
        if res == 0x40 {
            tokio::task::spawn(spawn_tunnel(conn_buff));
        }
    }

    //Ok(())
}

async fn spawn_tunnel(conn_buff: [u8; 64]) -> Result<()> {
    let mut local_stream = TcpStream::connect("127.0.0.1:80").await?;
    let mut tunnel_stream = TcpStream::connect(SERVER_ADDR).await?;
    local_stream.set_nodelay(true)?;

    tunnel_stream.write_all(&conn_buff).await?;
    tunnel_stream.set_nodelay(true)?;

    tokio::io::copy_bidirectional(&mut local_stream, &mut tunnel_stream).await?;
    Ok(())
}
